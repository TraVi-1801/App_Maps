package com.vic.project.app_maps.presentation.viewmodelimport android.util.Logimport androidx.lifecycle.viewModelScopeimport com.google.android.gms.maps.model.LatLngimport com.google.maps.android.SphericalUtilimport com.vic.project.app_maps.data.model.DirectionDataimport com.vic.project.app_maps.data.model.LatLongimport com.vic.project.app_maps.data.model.LocationDataimport com.vic.project.app_maps.data.model.Stepimport com.vic.project.app_maps.domain.repository.LocationRepositoryimport com.vic.project.app_maps.presentation.screens.ModelDirectionimport com.vic.project.app_maps.utils.AppConstantimport com.vic.project.app_maps.utils.JSONimport com.vic.project.app_maps.utils.JSON.toJsonimport com.vic.project.app_maps.utils.MapUtils.decodePolyimport com.vic.project.app_maps.utils.MapUtils.distanceBetweenimport com.vic.project.app_maps.utils.MapUtils.getNextStepimport com.vic.project.app_maps.utils.MapUtils.getRemainingPolylinePointsimport com.vic.project.app_maps.utils.MapUtils.isOffRouteimport dagger.hilt.android.lifecycle.HiltViewModelimport jakarta.inject.Injectimport kotlinx.coroutines.Jobimport kotlinx.coroutines.flow.distinctUntilChangedByimport kotlinx.coroutines.flow.launchInimport kotlinx.coroutines.flow.onEach@HiltViewModelclass HomeViewModel @Inject constructor(    private val locationRepository: LocationRepository) : BaseViewModel<State, Event>(State()) {    private var locationJob: Job? = null    init {        uiState.distinctUntilChangedBy { it.onFocus }.onEach {            if (it.onFocus) {                val list = locationRepository.getListHistory()                updateUiState(uiState.value.copy(listHistory = list))            }        }.launchIn(viewModelScope)    }    override fun handleEvent(event: Event) {        when (event) {            Event.GetLocationCurrent -> {                getLocationCurrent()            }            is Event.SearchLocation -> {                searchAddress(event.data)            }            is Event.UpdateFocus -> {                updateUiState(                    uiState.value.copy(                        onFocus = event.data                    )                )            }            is Event.UpdateSearch -> {                if (event.data.isNotBlank()) {                    getListRecommend(event.data)                    updateUiState(                        uiState.value.copy(                            search = event.data,                        )                    )                } else {                    updateUiState(                        uiState.value.copy(                            search = event.data, listRecommend = emptyList()                        )                    )                }            }            is Event.ChooseLocation -> {                updateUiState(                    uiState.value.copy(                        currentChoose = event.data,                        listResult = emptyList(),                    )                )            }            Event.ResetListResult -> {                updateUiState(                    uiState.value.copy(                        listResultSearch = emptyList(),                        showBottomSheet = false,                        search = ""                    )                )            }            is Event.GetDirections -> {                getDirections(event.start, event.end)            }            is Event.ChangeModel -> {                updateUiState(                    uiState.value.copy(                        currentModel = event.data                    )                )            }            Event.ResetDirection -> {                updateUiState(                    uiState.value.copy(                        directionDataDrive = null,                        directionDataWalk = null,                        directionDataTW = null,                        currentChoose = null,                        currentModel = ModelDirection.Driving,                        listDirectionsDrive = emptyList(),                        listDirectionsWalk = emptyList(),                        listDirectionsTW = emptyList(),                        startLocation = null,                        listResult = emptyList(),                        isDirection = false                    )                )            }            is Event.SearchLocationResult -> {                searchAddress_v2(event.data)            }            is Event.UpdateDirection -> {                updateUiState(                    uiState.value.copy(                        isDirection = event.data                    )                )            }            is Event.ChooseStartLocation -> {                updateUiState(                    uiState.value.copy(                        startLocation = event.data,                        listResult = emptyList(),                    )                )            }        }    }    fun startLocationUpdates() {        locationJob?.cancel()        locationJob = async {            locationRepository.getRealTimeLocation(uiState.value.latLong.convertLatLng())                .collect { location ->                    val listWent = uiState.value.listWent + listOf(location.convertLatLng())                    if (isOffRoute(location.convertLatLng(), when(uiState.value.currentModel){                            ModelDirection.Driving -> uiState.value.listDirectionsDrive                            ModelDirection.Walking -> uiState.value.listDirectionsWalk                            ModelDirection.Two_wheeler -> uiState.value.listDirectionsTW                    })) {                        val end = uiState.value.currentChoose?.geometry?.location?.convertLatLng()                        getDirectionsAgain(start = location.convertLatLng(), end = end)                        updateUiState(                            uiState.value.copy(                                latLong = location,                                listWent = listWent                            )                        )                    } else {                        val steps  = when(uiState.value.currentModel){                            ModelDirection.Driving -> uiState.value.directionDataDrive?.legs?.firstOrNull()?.steps.orEmpty()                            ModelDirection.Walking -> uiState.value.directionDataWalk?.legs?.firstOrNull()?.steps.orEmpty()                            ModelDirection.Two_wheeler -> uiState.value.directionDataTW?.legs?.firstOrNull()?.steps.orEmpty()                        }                        val fullPolyline  = when(uiState.value.currentModel){                            ModelDirection.Driving -> uiState.value.listDirectionsDrive                            ModelDirection.Walking -> uiState.value.listDirectionsWalk                            ModelDirection.Two_wheeler -> uiState.value.listDirectionsTW                        }                        val updatedPolyline = getRemainingPolylinePoints(fullPolyline, location.convertLatLng())                        val nextStep = getNextStep(location.convertLatLng(), steps)                        val check = distanceBetween(location.convertLatLng(), updatedPolyline.lastOrNull())                        if (check < 5) {                            updateUiState(                                uiState.value.copy(                                    isDone = true,                                    isStart = false                                )                            )                            stopLocationUpdates()                        } else {                            updateUiState(                                uiState.value.copy(                                    latLong = location,                                    step = nextStep,                                    listWent = listWent,                                    listDirectionsDrive = if (uiState.value.currentModel == ModelDirection.Driving) updatedPolyline else uiState.value.listDirectionsDrive,                                    listDirectionsWalk = if (uiState.value.currentModel == ModelDirection.Walking) updatedPolyline else uiState.value.listDirectionsWalk,                                    listDirectionsTW = if (uiState.value.currentModel == ModelDirection.Two_wheeler) updatedPolyline else uiState.value.listDirectionsTW,                                )                            )                        }                    }                }        }    }    fun stopLocationUpdates() {        locationJob?.cancel()        locationJob = null        updateUiState(            uiState.value.copy(                listResult = emptyList(),                listWent = emptyList(),                step = null,                isStart = false            )        )        handleEvent(            Event.ResetDirection        )        handleEvent(Event.ResetListResult)    }    private fun getDirections(        start: LatLng?,        end: LatLng?    ) {        async {            updateUiState(                uiState.value.copy(                    isLoad = true                )            )            locationRepository.getDirections(                start, end, ModelDirection.Driving.model            ).collectData (                doOnError = {                    updateUiState(                        uiState.value.copy(                            isLoad = false                        )                    )                }            ){                val data = JSON.decodeToList(it, Array<DirectionData>::class.java).orEmpty().firstOrNull()                val listDirections = decodePoly(data?.overview_polyline?.points)                updateUiState(                    uiState.value.copy(                        directionDataDrive = data,                        listDirectionsDrive = listDirections,                        isDirection = true,                        showBottomSheet = true,                        isLoad = false                    )                )            }            locationRepository.getDirections(                start, end, ModelDirection.Walking.model            ).collectData (                doOnError = {                    updateUiState(                        uiState.value.copy(                            isLoad = false                        )                    )                }            ){                val data = JSON.decodeToList(it, Array<DirectionData>::class.java).orEmpty().firstOrNull()                val listDirections = decodePoly(data?.overview_polyline?.points)                updateUiState(                    uiState.value.copy(                        directionDataWalk = data,                        listDirectionsWalk = listDirections,                        isDirection = true,                        showBottomSheet = true,                        isLoad = false                    )                )            }            locationRepository.getDirections(                start, end, ModelDirection.Two_wheeler.model            ).collectData (                doOnError = {                    updateUiState(                        uiState.value.copy(                            isLoad = false                        )                    )                }            ){                val data = JSON.decodeToList(it, Array<DirectionData>::class.java).orEmpty().firstOrNull()                val listDirections = decodePoly(data?.overview_polyline?.points)                updateUiState(                    uiState.value.copy(                        directionDataTW = data,                        listDirectionsTW = listDirections,                        isDirection = true,                        showBottomSheet = true,                        isLoad = false                    )                )            }        }    }    private fun getDirectionsAgain(        start: LatLng?,        end: LatLng?    ) {        async {            locationRepository.getDirections(                start, end, ModelDirection.Driving.model            ).collectData{                val data = JSON.decodeToList(it, Array<DirectionData>::class.java).orEmpty().firstOrNull()                val listDirections = decodePoly(data?.overview_polyline?.points)                updateUiState(                    uiState.value.copy(                        directionDataDrive = data,                        listDirectionsDrive = listDirections,                    )                )            }            locationRepository.getDirections(                start, end, ModelDirection.Walking.model            ).collectData {                val data = JSON.decodeToList(it, Array<DirectionData>::class.java).orEmpty().firstOrNull()                val listDirections = decodePoly(data?.overview_polyline?.points)                updateUiState(                    uiState.value.copy(                        directionDataWalk = data,                        listDirectionsWalk = listDirections,                    )                )            }            locationRepository.getDirections(                start, end, ModelDirection.Two_wheeler.model            ).collectData {                val data = JSON.decodeToList(it, Array<DirectionData>::class.java).orEmpty().firstOrNull()                val listDirections = decodePoly(data?.overview_polyline?.points)                updateUiState(                    uiState.value.copy(                        directionDataTW = data,                        listDirectionsTW = listDirections,                    )                )            }        }    }    private fun searchAddress(data: String) {        async {            updateUiState(                uiState.value.copy(                    search = data,                    isLoad = true,                    showBottomSheet = true                )            )            locationRepository.searchPlace(data).collectData (                doOnError = {                    updateUiState(                        uiState.value.copy(                            isLoad = false                        )                    )                }            ){                val item =                    JSON.decodeToList(it, Array<LocationData>::class.java).orEmpty()                locationRepository.addHistory(data)                updateUiState(                    uiState.value.copy(                        listResultSearch = item,                        isLoad = false                    )                )            }        }    }    fun hideBottomSheet(data: Boolean){        updateUiState(            uiState.value.copy(                showBottomSheet = data            )        )    }    fun startDirection(data: Boolean){        updateUiState(            uiState.value.copy(                isStart = data            )        )    }    fun isDone(data: Boolean){        updateUiState(            uiState.value.copy(                isDone = data            )        )    }    private fun searchAddress_v2(data: String) {        async {            locationRepository.searchPlace(data).collectData {                val item = JSON.decodeToList(it, Array<LocationData>::class.java).orEmpty().take(5)                updateUiState(                    uiState.value.copy(                        listResult = item,                    )                )            }        }    }    private fun getListRecommend(data: String) {        async {            locationRepository.getPlaceRecommend(data).collectData {                val data = JSON.decodeToList(it, Array<LocationData>::class.java).orEmpty()                    .map { it.description }.take(5)                updateUiState(                    uiState.value.copy(                        listRecommend = data                    )                )            }        }    }    private fun getLocationCurrent() {        async {            locationRepository.getCurrentLocation().collect {                updateUiState(                    uiState.value.copy(                        latLong = it                    )                )            }        }    }}sealed interface Event {    data object GetLocationCurrent : Event    data class UpdateSearch(val data: String) : Event    data class UpdateFocus(val data: Boolean) : Event    data class UpdateDirection(val data: Boolean) : Event    data class SearchLocation(val data: String) : Event    data class SearchLocationResult(val data: String) : Event    data class ChooseLocation(val data: LocationData) : Event    data class ChooseStartLocation(val data: LocationData) : Event    data class ChangeModel(val data: ModelDirection) : Event    data class GetDirections(val start: LatLng?, val end: LatLng?) : Event    data object ResetListResult : Event    data object ResetDirection : Event}data class State(    val latLong: LatLong = AppConstant.fallbackLocation,    val startLocation: LocationData? = null,    val currentChoose: LocationData? = null,    val directionDataDrive: DirectionData? = null,    val directionDataWalk: DirectionData? = null,    val directionDataTW: DirectionData? = null,    val step: Step? = null,    val search: String = "",    val listHistory: List<String> = emptyList(),    val listRecommend: List<String> = emptyList(),    val listDirectionsDrive: List<LatLng> = emptyList(),    val listDirectionsWalk: List<LatLng> = emptyList(),    val listDirectionsTW: List<LatLng> = emptyList(),    val listWent: List<LatLng> = emptyList(),    val listResultSearch: List<LocationData> = emptyList(),    val listResult: List<LocationData> = emptyList(),    val currentModel: ModelDirection = ModelDirection.Driving,    val onFocus: Boolean = false,    val isLoad: Boolean = false,    val showBottomSheet: Boolean = false,    val isDirection: Boolean = false,    val isStart: Boolean = false,    val isDone: Boolean = false,)