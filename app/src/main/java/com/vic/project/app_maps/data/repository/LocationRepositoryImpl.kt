package com.vic.project.app_maps.data.repositoryimport android.annotation.SuppressLintimport android.content.Contextimport android.location.Locationimport android.location.LocationManagerimport com.google.android.gms.location.FusedLocationProviderClientimport com.google.android.gms.location.Priorityimport com.vic.project.app_maps.BuildConfigimport com.vic.project.app_maps.data.model.LatLongimport com.vic.project.app_maps.data.preferences.Preferencesimport com.vic.project.app_maps.data.remote.model.request.KeyRequestimport com.vic.project.app_maps.data.remote.model.response.BaseResponseimport com.vic.project.app_maps.data.remote.model.response.ResultWrapperimport com.vic.project.app_maps.data.remote.service.RetrofitServiceimport com.vic.project.app_maps.domain.repository.LocationRepositoryimport com.vic.project.app_maps.utils.AppConstant.fallbackLocationimport com.vic.project.app_maps.utils.ContextUtils.hasCoarseLocationimport com.vic.project.app_maps.utils.ContextUtils.hasFineLocationimport com.vic.project.app_maps.utils.FlowUtils.emitLoadingimport com.vic.project.app_maps.utils.JSONimport com.vic.project.app_maps.utils.JSON.toJsonimport jakarta.inject.Injectimport kotlinx.coroutines.CoroutineDispatcherimport kotlinx.coroutines.channels.awaitCloseimport kotlinx.coroutines.flow.Flowimport kotlinx.coroutines.flow.callbackFlowimport kotlinx.coroutines.flow.flowimport kotlinx.coroutines.flow.flowOnimport javax.inject.Namedclass LocationRepositoryImpl @Inject constructor(    private val context: Context,    private val preferences: Preferences,    private val locationClient: FusedLocationProviderClient,    private val retrofitService: RetrofitService,    @Named("io") private val ioDispatcher: CoroutineDispatcher) : LocationRepository {    @SuppressLint("MissingPermission")    override fun getCurrentLocation(): Flow<LatLong> = callbackFlow {        if (!context.hasFineLocation() && !context.hasCoarseLocation()) {            trySend(fallbackLocation)            close()            return@callbackFlow        }        val locationManager = context.getSystemService(Context.LOCATION_SERVICE) as LocationManager        val isGpsEnabled = locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)        val onSuccess: (Location?) -> Unit = { loc ->            trySend(                if (loc != null) LatLong(loc.latitude, loc.longitude, loc.bearing)                else fallbackLocation            )            close()        }        val onFailure: (Exception) -> Unit = {            trySend(fallbackLocation)            close()        }        if (!isGpsEnabled) {            locationClient.lastLocation                .addOnSuccessListener(onSuccess)                .addOnFailureListener(onFailure)        } else {            locationClient.getCurrentLocation(Priority.PRIORITY_HIGH_ACCURACY, null)                .addOnSuccessListener(onSuccess)                .addOnFailureListener(onFailure)        }        awaitClose()    }    override fun getPlaceRecommend(address: String): Flow<ResultWrapper<BaseResponse>> {        return flow {            val response = retrofitService.getMethod(                headers = HashMap(),                request = KeyRequest.PLACE_AUTO,                message = "input=${address}&language=en&key=${BuildConfig.API_KEY}",                codeRequired = KeyRequest.PLACE_AUTO.codeResponse            )            emit(response)        }.emitLoading().flowOn(ioDispatcher)    }    override fun searchPlace(address: String): Flow<ResultWrapper<BaseResponse>> {        return flow {            val response = retrofitService.getMethod(                headers = HashMap(),                request = KeyRequest.PLACE_SEARCH,                message = "input=${address}&language=en&inputtype=textquery&key=${BuildConfig.API_KEY}",                codeRequired = KeyRequest.PLACE_SEARCH.codeResponse            )            emit(response)        }.emitLoading().flowOn(ioDispatcher)    }    override fun getListHistory(): List<String> {        return JSON.decodeToList(preferences.listSearch, Array<String>::class.java).orEmpty()            .take(5)    }    override fun addHistory(data: String) {        val listData =            JSON.decodeToList(preferences.listSearch, Array<String>::class.java).orEmpty()                .toMutableList().also {                    it.remove(data)                    it.add(0, data)                }        preferences.listSearch = listData.toJson()    }}