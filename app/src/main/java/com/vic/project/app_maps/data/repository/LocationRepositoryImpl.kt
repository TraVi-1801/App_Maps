package com.vic.project.app_maps.data.repositoryimport android.Manifestimport android.annotation.SuppressLintimport android.content.Contextimport android.location.Locationimport android.location.LocationManagerimport android.os.Looperimport androidx.annotation.RequiresPermissionimport com.google.android.gms.location.FusedLocationProviderClientimport com.google.android.gms.location.LocationCallbackimport com.google.android.gms.location.LocationRequestimport com.google.android.gms.location.LocationResultimport com.google.android.gms.location.Priorityimport com.google.android.gms.maps.model.LatLngimport com.vic.project.app_maps.BuildConfigimport com.vic.project.app_maps.data.model.LatLongimport com.vic.project.app_maps.data.preferences.Preferencesimport com.vic.project.app_maps.data.remote.model.request.KeyRequestimport com.vic.project.app_maps.data.remote.model.response.BaseResponseimport com.vic.project.app_maps.data.remote.model.response.ResultWrapperimport com.vic.project.app_maps.data.remote.service.RetrofitServiceimport com.vic.project.app_maps.domain.repository.LocationRepositoryimport com.vic.project.app_maps.utils.AppConstant.fallbackLocationimport com.vic.project.app_maps.utils.ContextUtils.hasForegroundLocationimport com.vic.project.app_maps.utils.FlowUtils.emitLoadingimport com.vic.project.app_maps.utils.JSONimport com.vic.project.app_maps.utils.JSON.toJsonimport jakarta.inject.Injectimport kotlinx.coroutines.CoroutineDispatcherimport kotlinx.coroutines.Jobimport kotlinx.coroutines.channels.Channelimport kotlinx.coroutines.channels.awaitCloseimport kotlinx.coroutines.channels.onFailureimport kotlinx.coroutines.flow.Flowimport kotlinx.coroutines.flow.bufferimport kotlinx.coroutines.flow.callbackFlowimport kotlinx.coroutines.flow.flowimport kotlinx.coroutines.flow.flowOnimport javax.inject.Namedclass LocationRepositoryImpl @Inject constructor(    private val context: Context,    private val preferences: Preferences,    private val locationClient: FusedLocationProviderClient,    private val retrofitService: RetrofitService,    @Named("io") private val ioDispatcher: CoroutineDispatcher) : LocationRepository {    @SuppressLint("MissingPermission")    override fun getCurrentLocation(): Flow<LatLong> = callbackFlow {        if (!context.hasForegroundLocation()) {            trySend(fallbackLocation)            close()            return@callbackFlow        }        val locationManager = context.getSystemService(Context.LOCATION_SERVICE) as LocationManager        val isGpsEnabled = locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)        val onSuccess: (Location?) -> Unit = { loc ->            trySend(                if (loc != null) LatLong(loc.latitude, loc.longitude, loc.bearing)                else fallbackLocation            )            close()        }        val onFailure: (Exception) -> Unit = {            trySend(fallbackLocation)            close()        }        if (!isGpsEnabled) {            locationClient.lastLocation                .addOnSuccessListener(onSuccess)                .addOnFailureListener(onFailure)        } else {            locationClient.getCurrentLocation(Priority.PRIORITY_HIGH_ACCURACY, null)                .addOnSuccessListener(onSuccess)                .addOnFailureListener(onFailure)        }        awaitClose()    }    @SuppressLint("MissingPermission")    override fun getRealTimeLocation(current: LatLng): Flow<LatLong> = callbackFlow {        if (!context.hasForegroundLocation()) {            trySend(LatLong(current.latitude, current.longitude))            close()            return@callbackFlow        }        val locationRequest = LocationRequest.Builder(            Priority.PRIORITY_HIGH_ACCURACY,            10_000L        ).build()        val locationCallback = object : LocationCallback() {            override fun onLocationResult(result: LocationResult) {                result.lastLocation?.let { location ->                    trySend(                        LatLong(                            lat = location.latitude,                            long = location.longitude,                            bearing = location.bearing                        )                    )                }            }        }        locationClient.requestLocationUpdates(            locationRequest,            locationCallback,            Looper.getMainLooper()        ).addOnFailureListener { e ->            close(e)        }        awaitClose {            locationClient.removeLocationUpdates(locationCallback)        }    }.buffer(Channel.CONFLATED)    override fun getPlaceRecommend(address: String): Flow<ResultWrapper<BaseResponse>> {        return flow {            val response = retrofitService.getMethod(                headers = HashMap(),                request = KeyRequest.PLACE_AUTO,                message = "input=${address}&key=${BuildConfig.API_KEY}",                codeRequired = KeyRequest.PLACE_AUTO.codeResponse            )            emit(response)        }.emitLoading().flowOn(ioDispatcher)    }    override fun searchPlace(address: String): Flow<ResultWrapper<BaseResponse>> {        return flow {            val response = retrofitService.getMethod(                headers = HashMap(),                request = KeyRequest.PLACE_SEARCH,                message = "query=${address}&key=${BuildConfig.API_KEY}",                codeRequired = KeyRequest.PLACE_SEARCH.codeResponse            )            emit(response)        }.emitLoading().flowOn(ioDispatcher)    }    override fun getDirections(        start: LatLng?,        end: LatLng?,        model: String    ): Flow<ResultWrapper<BaseResponse>> {        return flow {            val response = retrofitService.getMethod(                headers = HashMap(),                request = KeyRequest.DIRECTIONS,                message = "origin=${start?.latitude},${start?.longitude}&destination=${end?.latitude},${end?.longitude}&mode=${model}&key=${BuildConfig.API_KEY}",                codeRequired = KeyRequest.DIRECTIONS.codeResponse            )            emit(response)        }.emitLoading().flowOn(ioDispatcher)    }    override fun getListHistory(): List<String> {        return JSON.decodeToList(preferences.listSearch, Array<String>::class.java).orEmpty()            .take(5)    }    override fun addHistory(data: String) {        val listData =            JSON.decodeToList(preferences.listSearch, Array<String>::class.java).orEmpty()                .toMutableList().also {                    it.remove(data)                    it.add(0, data)                }        preferences.listSearch = listData.toJson()    }}